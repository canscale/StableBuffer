<!DOCTYPE html>
<html><head title="Doc"><meta charset="UTF-8"/><link href="styles.css" rel="stylesheet"/></head><body><nav class="sidebar"><h3>Modules</h3><ul><li><li><a href="StableBuffer.html">StableBuffer</a></li></li></ul><h3>Declarations</h3><ul><li><li><a href="#type.StableBuffer">StableBuffer</a></li></li><li><li><a href="#initPresized">initPresized</a></li></li><li><li><a href="#init">init</a></li></li><li><li><a href="#add">add</a></li></li><li><li><a href="#remove">remove</a></li></li><li><li><a href="#removeLast">removeLast</a></li></li><li><li><a href="#append">append</a></li></li><li><li><a href="#size">size</a></li></li><li><li><a href="#capacity">capacity</a></li></li><li><li><a href="#reserve">reserve</a></li></li><li><li><a href="#clear">clear</a></li></li><li><li><a href="#clone">clone</a></li></li><li><li><a href="#vals">vals</a></li></li><li><li><a href="#fromArray">fromArray</a></li></li><li><li><a href="#toArray">toArray</a></li></li><li><li><a href="#toVarArray">toVarArray</a></li></li><li><li><a href="#get">get</a></li></li><li><li><a href="#getOpt">getOpt</a></li></li><li><li><a href="#put">put</a></li></li><li><li><a href="#contains">contains</a></li></li><li><li><a href="#indexOf">indexOf</a></li></li><li><li><a href="#filterEntries">filterEntries</a></li></li><li><li><a href="#insert">insert</a></li></li><li><li><a href="#insertBuffer">insertBuffer</a></li></li><li><li><a href="#sort">sort</a></li></li><li><li><a href="#isEmpty">isEmpty</a></li></li><li><li><a href="#max">max</a></li></li><li><li><a href="#min">min</a></li></li><li><li><a href="#equal">equal</a></li></li><li><li><a href="#compare">compare</a></li></li><li><li><a href="#toText">toText</a></li></li><li><li><a href="#hash">hash</a></li></li><li><li><a href="#lastIndexOf">lastIndexOf</a></li></li><li><li><a href="#indexOfBuffer">indexOfBuffer</a></li></li><li><li><a href="#binarySearch">binarySearch</a></li></li><li><li><a href="#subBuffer">subBuffer</a></li></li><li><li><a href="#isSubBufferOf">isSubBufferOf</a></li></li><li><li><a href="#isStrictSubBufferOf">isStrictSubBufferOf</a></li></li><li><li><a href="#prefix">prefix</a></li></li><li><li><a href="#isPrefixOf">isPrefixOf</a></li></li><li><li><a href="#isStrictPrefixOf">isStrictPrefixOf</a></li></li><li><li><a href="#suffix">suffix</a></li></li><li><li><a href="#isSuffixOf">isSuffixOf</a></li></li><li><li><a href="#isStrictSuffixOf">isStrictSuffixOf</a></li></li><li><li><a href="#forAll">forAll</a></li></li><li><li><a href="#forSome">forSome</a></li></li><li><li><a href="#forNone">forNone</a></li></li><li><li><a href="#fromVarArray">fromVarArray</a></li></li><li><li><a href="#fromIter">fromIter</a></li></li><li><li><a href="#trimToSize">trimToSize</a></li></li><li><li><a href="#map">map</a></li></li><li><li><a href="#iterate">iterate</a></li></li><li><li><a href="#mapEntries">mapEntries</a></li></li><li><li><a href="#mapFilter">mapFilter</a></li></li><li><li><a href="#mapResult">mapResult</a></li></li><li><li><a href="#chain">chain</a></li></li><li><li><a href="#foldLeft">foldLeft</a></li></li><li><li><a href="#foldRight">foldRight</a></li></li><li><li><a href="#first">first</a></li></li><li><li><a href="#last">last</a></li></li><li><li><a href="#make">make</a></li></li><li><li><a href="#reverse">reverse</a></li></li><li><li><a href="#merge">merge</a></li></li><li><li><a href="#removeDuplicates">removeDuplicates</a></li></li><li><li><a href="#partition">partition</a></li></li><li><li><a href="#split">split</a></li></li><li><li><a href="#chunk">chunk</a></li></li><li><li><a href="#groupBy">groupBy</a></li></li><li><li><a href="#flatten">flatten</a></li></li><li><li><a href="#zip">zip</a></li></li><li><li><a href="#zipWith">zipWith</a></li></li><li><li><a href="#takeWhile">takeWhile</a></li></li><li><li><a href="#dropWhile">dropWhile</a></li></li></ul></nav><div class="documentation"><h1>StableBuffer</h1><p>Generic, extensible buffers</p>
<p><code>StableBuffer&lt;X&gt;</code> is adapted directly from https://github.com/dfinity/motoko-base/blob/master/src/Buffer.mo,
ripping all functions and instance variables out of the <code>Buffer</code> class in order to make a stable, persistent
buffer.</p>
<p>Generic, mutable sequences that grow to accommodate arbitrary numbers of elements.</p>
<p><code>StableBuffer&lt;X&gt;</code> provides extensible, mutable sequences of elements of type <code>X</code>.
that can be efficiently produced and consumed with imperative code.
A buffer object can be extended by a single element or the contents of another buffer object.</p>
<p>When required, the current state of a buffer object can be converted to a fixed-size array of its elements.</p>
<p>Buffers complement Motoko's non-extensible array types
(arrays do not support efficient extension, because the size of an array is
determined at construction and cannot be changed).</p>
<div class="declaration"><h4 class="type-declaration" id="type.StableBuffer"><span class="keyword">type </span><span class="type">StableBuffer</span>&lt;<span class="type">X</span>&gt; = { initCapacity : <span class="type">Nat</span>; <span class="keyword">var </span>count : <span class="type">Nat</span>; <span class="keyword">var </span>elems : [<span class="keyword">var </span>?<span class="type">X</span>] }</h4><p></p></div><div class="declaration"><h4 class="function" id="initPresized"><code><span class="keyword">public func </span><span class="fnname">initPresized</span>&lt;<span class="type">X</span>&gt;(<span class="parameter">initCapacity</span> : <span class="type">Nat</span>) : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;</code></h4><p><p>Initializes a buffer of given initial capacity. Note that this capacity is not realized until an element
is added to the buffer.</p>
</p></div><div class="declaration"><h4 class="function" id="init"><code><span class="keyword">public func </span><span class="fnname">init</span>&lt;<span class="type">X</span>&gt;() : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;</code></h4><p><p>Initializes a buffer of initial capacity 0. When the first element is added the size will grow to one</p>
</p></div><div class="declaration"><h4 class="function" id="add"><code><span class="keyword">public func </span><span class="fnname">add</span>&lt;<span class="type">X</span>&gt;(<span class="parameter">buffer</span> : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;, <span class="parameter">element</span> : <span class="type">X</span>)</code></h4><p><p>Adds a single element to the end of the buffer, doubling
the size of the array if capacity is exceeded.</p>
<p>Example:</p>
<pre><code>motoko include=initialize

StableBuffer.add(buffer, 0); // add 0 to buffer
StableBuffer.add(buffer, 1);
StableBuffer.add(buffer, 2);
StableBuffer.add(buffer, 3); // causes underlying array to increase in capacity
StableBuffer.toArray(buffer) // =&gt; [0, 1, 2, 3]</code></pre>

<p>Amortized Runtime: O(1), Worst Case Runtime: O(size)</p>
<p>Amortized Space: O(1), Worst Case Space: O(size)</p>
</p></div><div class="declaration"><h4 class="function" id="remove"><code><span class="keyword">public func </span><span class="fnname">remove</span>&lt;<span class="type">X</span>&gt;(<span class="parameter">buffer</span> : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;, <span class="parameter">index</span> : <span class="type">Nat</span>) : <span class="type">X</span></code></h4><p><p>Removes and returns the element at <code>index</code> from the buffer.
All elements with index &gt; <code>index</code> are shifted one position to the left.
This may cause a downsizing of the array.</p>
<p>Traps if index &gt;= size.</p>
<p>WARNING: Repeated removal of elements using this method is ineffecient
and might be a sign that you should consider a different data-structure
for your use case.</p>
<p>Example:</p>
<pre><code>motoko include=initialize

StableBuffer.add(buffer, 10);
StableBuffer.add(buffer, 11);
StableBuffer.add(buffer, 12);
let x = StableBuffer.remove(buffer, 1); // evaluates to 11. 11 no longer in list.
StableBuffer.toArray(buffer) // =&gt; [10, 12]</code></pre>

<p>Runtime: O(size)</p>
<p>Amortized Space: O(1), Worst Case Space: O(size)</p>
</p></div><div class="declaration"><h4 class="function" id="removeLast"><code><span class="keyword">public func </span><span class="fnname">removeLast</span>&lt;<span class="type">X</span>&gt;(<span class="parameter">buffer</span> : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;) : ?<span class="type">X</span></code></h4><p><p>Removes and returns the last item in the buffer or <code>null</code> if
the buffer is empty.</p>
<p>Example:</p>
<pre><code>motoko include=initialize

StableBuffer.add(buffer, 10);
StableBuffer.add(buffer, 11);
StableBuffer.removeLast(buffer); // =&gt; ?11</code></pre>

<p>Amortized Runtime: O(1), Worst Case Runtime: O(size)</p>
<p>Amortized Space: O(1), Worst Case Space: O(size)</p>
</p></div><div class="declaration"><h4 class="function" id="append"><code><span class="keyword">public func </span><span class="fnname">append</span>&lt;<span class="type">X</span>&gt;(<span class="parameter">buffer</span> : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;, <span class="parameter">buffer2</span> : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;)</code></h4><p><p>Adds all elements in buffer <code>b</code> to this buffer.</p>
<pre><code>motoko include=initialize
let buffer1 = StableBuffer.initPresized&lt;Nat&gt;(2);
let buffer2 = StableBuffer.initPresized&lt;Nat&gt;(2);
StableBuffer.add(buffer1, 10);
StableBuffer.add(buffer1, 11);
StableBuffer.add(buffer2, 12);
StableBuffer.add(buffer2, 13);
StableBuffer.append(buffer1, buffer2); // adds elements from buffer2 to buffer1
StableBuffer.toArray(buffer1) // =&gt; [10, 11, 12, 13]</code></pre>

<p>Amortized Runtime: O(size2), Worst Case Runtime: O(size1 + size2)</p>
<p>Amortized Space: O(1), Worst Case Space: O(size1 + size2)</p>
</p></div><div class="declaration"><h4 class="function" id="size"><code><span class="keyword">public func </span><span class="fnname">size</span>&lt;<span class="type">X</span>&gt;(<span class="parameter">buffer</span> : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;) : <span class="type">Nat</span></code></h4><p><p>Returns the current number of elements in the buffer.</p>
<p>Example:</p>
<pre><code>motoko include=initialize
size(buffer) // =&gt; 0</code></pre>

<p>Runtime: O(1)</p>
<p>Space: O(1)</p>
</p></div><div class="declaration"><h4 class="function" id="capacity"><code><span class="keyword">public func </span><span class="fnname">capacity</span>&lt;<span class="type">X</span>&gt;(<span class="parameter">buffer</span> : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;) : <span class="type">Nat</span></code></h4><p><p>Returns the capacity of the buffer (the length of the underlying array).</p>
<p>Example:</p>
<pre><code>motoko include=initialize

let buffer = StableBuffer.initPresized&lt;Nat&gt;(2); // underlying array has capacity 2
StableBuffer.add(buffer, 10);
let c1 = StableBuffer.capacity(buffer); // =&gt; 2
StableBuffer.add(buffer, 11);
StableBuffer.add(buffer, 12); // causes capacity to increase by factor of 1.5
let c2 = StableBuffer.capacity(buffer); // =&gt; 3</code></pre>

<p>Runtime: O(1)</p>
<p>Space: O(1)</p>
</p></div><div class="declaration"><h4 class="function" id="reserve"><code><span class="keyword">public func </span><span class="fnname">reserve</span>&lt;<span class="type">X</span>&gt;(<span class="parameter">buffer</span> : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;, <span class="parameter">capacity</span> : <span class="type">Nat</span>)</code></h4><p><p>Changes the capacity to <code>capacity</code>. Traps if <code>capacity</code> &lt; <code>size</code>.</p>
<pre><code>motoko include=initialize

StableBuffer.reserve(buffer, 4);
StableBuffer.add(buffer, 10);
StableBuffer.add(buffer, 11);
StableBuffer.capacity(buffer); // =&gt; 4</code></pre>

<p>Runtime: O(capacity)</p>
<p>Space: O(capacity)</p>
</p></div><div class="declaration"><h4 class="function" id="clear"><code><span class="keyword">public func </span><span class="fnname">clear</span>&lt;<span class="type">X</span>&gt;(<span class="parameter">buffer</span> : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;)</code></h4><p><p>Resets the buffer. Capacity is set to 8.</p>
<p>Example:</p>
<pre><code>motoko include=initialize

StableBuffer.add(buffer, 10);
StableBuffer.add(buffer, 11);
StableBuffer.add(buffer, 12);
StableBuffer.clear(buffer, ); // buffer is now empty
StableBuffer.toArray(buffer) // =&gt; []</code></pre>

<p>Runtime: O(1)</p>
<p>Space: O(1)</p>
</p></div><div class="declaration"><h4 class="function" id="clone"><code><span class="keyword">public func </span><span class="fnname">clone</span>&lt;<span class="type">X</span>&gt;(<span class="parameter">buffer</span> : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;) : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;</code></h4><p><p>Returns a copy of <code>buffer</code>, with the same capacity.</p>
<p>Example:</p>
<pre><code>motoko include=initialize

StableBuffer.add(buffer, 1);

let clone = StableBuffer.clone(buffer);
StableBuffer.toArray(clone); // =&gt; [1]</code></pre>

<p>Runtime: O(size)</p>
<p>Space: O(size)</p>
</p></div><div class="declaration"><h4 class="function" id="vals"><code><span class="keyword">public func </span><span class="fnname">vals</span>&lt;<span class="type">X</span>&gt;(<span class="parameter">buffer</span> : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;) : { next : () -&gt; ?<span class="type">X</span> }</code></h4><p><p>Returns an Iterator (<code>Iter</code>) over the elements of this buffer.
Iterator provides a single method <code>next()</code>, which returns
elements in order, or <code>null</code> when out of elements to iterate over.</p>
<pre><code>motoko include=initialize

StableBuffer.add(buffer, 10);
StableBuffer.add(buffer, 11);
StableBuffer.add(buffer, 12);

var sum = 0;
for (element in StableBuffer.vals(buffer, )) {
  sum += element;
};
sum // =&gt; 33</code></pre>

<p>Runtime: O(1)</p>
<p>Space: O(1)</p>
</p></div><div class="declaration"><h4 class="function" id="fromArray"><code><span class="keyword">public func </span><span class="fnname">fromArray</span>&lt;<span class="type">X</span>&gt;(<span class="parameter">array</span> : [<span class="type">X</span>]) : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;</code></h4><p><p>Creates a buffer containing elements from <code>array</code>.</p>
<p>Example:</p>
<pre><code>motoko include=initialize
import Nat &quot;mo:base/Nat&quot;;

let array = [2, 3];

let buf = StableBuffer.fromArray&lt;Nat&gt;(array); // =&gt; [2, 3]
StableBuffer.toText(buf, Nat.toText);</code></pre>

<p>Runtime: O(size)</p>
<p>Space: O(size)</p>
</p></div><div class="declaration"><h4 class="function" id="toArray"><code><span class="keyword">public func </span><span class="fnname">toArray</span>&lt;<span class="type">X</span>&gt;(<span class="parameter">buffer</span> : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;) : [<span class="type">X</span>]</code></h4><p><p>Creates an array containing elements from <code>buffer</code>.</p>
<p>Example:</p>
<pre><code>motoko include=initialize

StableBuffer.add(buffer, 1);
StableBuffer.add(buffer, 2);
StableBuffer.add(buffer, 3);

StableBuffer.toArray&lt;Nat&gt;(buffer); // =&gt; [1, 2, 3]

</code></pre>

<p>Runtime: O(size)</p>
<p>Space: O(size)</p>
</p></div><div class="declaration"><h4 class="function" id="toVarArray"><code><span class="keyword">public func </span><span class="fnname">toVarArray</span>&lt;<span class="type">X</span>&gt;(<span class="parameter">buffer</span> : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;) : [<span class="keyword">var </span><span class="type">X</span>]</code></h4><p><p>Creates a mutable array containing elements from <code>buffer</code>.</p>
<p>Example:</p>
<pre><code>motoko include=initialize

StableBuffer.add(buffer, 1);
StableBuffer.add(buffer, 2);
StableBuffer.add(buffer, 3);

StableBuffer.toVarArray&lt;Nat&gt;(buffer); // =&gt; [1, 2, 3]</code></pre>

<p>Runtime: O(size)</p>
<p>Space: O(size)</p>
</p></div><div class="declaration"><h4 class="function" id="get"><code><span class="keyword">public func </span><span class="fnname">get</span>&lt;<span class="type">X</span>&gt;(<span class="parameter">buffer</span> : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;, <span class="parameter">index</span> : <span class="type">Nat</span>) : <span class="type">X</span></code></h4><p><p>Returns the element at index <code>index</code>. Traps if  <code>index &gt;= size</code>. Indexing is zero-based.</p>
<p>Example:</p>
<pre><code>motoko include=initialize

StableBuffer.add(buffer,10);
StableBuffer.add(buffer,11);
StableBuffer.get(buffer,0); // =&gt; 10</code></pre>

<p>Runtime: O(1)</p>
<p>Space: O(1)</p>
</p></div><div class="declaration"><h4 class="function" id="getOpt"><code><span class="keyword">public func </span><span class="fnname">getOpt</span>&lt;<span class="type">X</span>&gt;(<span class="parameter">buffer</span> : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;, <span class="parameter">index</span> : <span class="type">Nat</span>) : ?<span class="type">X</span></code></h4><p><p>Returns the element at index <code>index</code> as an option.
Returns <code>null</code> when <code>index &gt;= size</code>. Indexing is zero-based.</p>
<p>Example:</p>
<pre><code>motoko include=initialize

StableBuffer.add(buffer, 10);
StableBuffer.add(buffer, 11);
let x = StableBuffer.getOpt(buffer, 0); // =&gt; ?10
let y = StableBuffer.getOpt(buffer, 2); // =&gt; null</code></pre>

<p>Runtime: O(1)</p>
<p>Space: O(1)</p>
</p></div><div class="declaration"><h4 class="function" id="put"><code><span class="keyword">public func </span><span class="fnname">put</span>&lt;<span class="type">X</span>&gt;(<br/>  <span class="parameter">buffer</span> : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;, <br/>  <span class="parameter">index</span> : <span class="type">Nat</span>, <br/>  <span class="parameter">element</span> : <span class="type">X</span><br/>)</code></h4><p><p>Overwrites the current element at <code>index</code> with <code>element</code>. Traps if
<code>index</code> &gt;= size. Indexing is zero-based.</p>
<p>Example:</p>
<pre><code>motoko include=initialize

StableBuffer.add(buffer, 10);
StableBuffer.put(buffer, 0, 20); // overwrites 10 at index 0 with 20
StableBuffer.toArray(Buffer, buffer) // =&gt; [20]</code></pre>

<p>Runtime: O(1)</p>
<p>Space: O(1)</p>
</p></div><div class="declaration"><h4 class="function" id="contains"><code><span class="keyword">public func </span><span class="fnname">contains</span>&lt;<span class="type">X</span>&gt;(<br/>  <span class="parameter">buffer</span> : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;, <br/>  <span class="parameter">element</span> : <span class="type">X</span>, <br/>  <span class="parameter">equal</span> : (<span class="type">X</span>, <span class="type">X</span>) -&gt; <span class="type">Bool</span><br/>) : <span class="type">Bool</span></code></h4><p><p>Returns true iff <code>buffer</code> contains <code>element</code> with respect to equality
defined by <code>equal</code>.</p>
<p>Example:</p>
<pre><code>motoko include=initialize
import Nat &quot;mo:base/Nat&quot;;

StableBuffer.add(buffer, 2);
StableBuffer.add(buffer, 0);
StableBuffer.add(buffer, 3);
StableBuffer.contains&lt;Nat&gt;(buffer, 2, Nat.equal); // =&gt; true</code></pre>

<p>Runtime: O(size)</p>
<p>Space: O(1)</p>
<p>*Runtime and space assumes that <code>equal</code> runs in O(1) time and space.</p>
</p></div><div class="declaration"><h4 class="function" id="indexOf"><code><span class="keyword">public func </span><span class="fnname">indexOf</span>&lt;<span class="type">X</span>&gt;(<br/>  <span class="parameter">element</span> : <span class="type">X</span>, <br/>  <span class="parameter">buffer</span> : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;, <br/>  <span class="parameter">equal</span> : (<span class="type">X</span>, <span class="type">X</span>) -&gt; <span class="type">Bool</span><br/>) : ?<span class="type">Nat</span></code></h4><p><p>Finds the first index of <code>element</code> in <code>buffer</code> using equality of elements defined
by <code>equal</code>. Returns <code>null</code> if <code>element</code> is not found.</p>
<p>Example:</p>
<pre><code>motoko include=initialize
import Nat &quot;mo:base/Nat&quot;;

StableBuffer.add(buffer, 1);
StableBuffer.add(buffer, 2);
StableBuffer.add(buffer, 3);
StableBuffer.add(buffer, 4);

StableBuffer.indexOf&lt;Nat&gt;(3, buffer, Nat.equal); // =&gt; ?2</code></pre>

<p>Runtime: O(size)</p>
<p>Space: O(size)</p>
<p>*Runtime and space assumes that <code>equal</code> runs in O(1) time and space.</p>
</p></div><div class="declaration"><h4 class="function" id="filterEntries"><code><span class="keyword">public func </span><span class="fnname">filterEntries</span>&lt;<span class="type">X</span>&gt;(<span class="parameter">buffer</span> : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;, <span class="parameter">predicate</span> : (<span class="type">Nat</span>, <span class="type">X</span>) -&gt; <span class="type">Bool</span>)</code></h4><p><p>Removes all elements from the buffer for which the predicate returns false.
The predicate is given both the index of the element and the element itself.
This may cause a downsizing of the array.</p>
<p>Example:</p>
<pre><code>motoko include=initialize

StableBuffer.add(buffer, 10);
StableBuffer.add(buffer, 11);
StableBuffer.add(buffer, 12);
StableBuffer.filterEntries(buffer, func(_, x) = x % 2 == 0); // only keep even elements
StableBuffer.toArray(buffer) // =&gt; [10, 12]</code></pre>

<p>Runtime: O(size)</p>
<p>Amortized Space: O(1), Worst Case Space: O(size)</p>
</p></div><div class="declaration"><h4 class="function" id="insert"><code><span class="keyword">public func </span><span class="fnname">insert</span>&lt;<span class="type">X</span>&gt;(<br/>  <span class="parameter">buffer</span> : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;, <br/>  <span class="parameter">index</span> : <span class="type">Nat</span>, <br/>  <span class="parameter">element</span> : <span class="type">X</span><br/>)</code></h4><p><p>Inserts <code>element</code> at <code>index</code>, shifts all elements to the right of
<code>index</code> over by one index. Traps if <code>index</code> is greater than size.</p>
<pre><code>motoko include=initialize
let buffer1 = StableBuffer.initPresized&lt;Nat&gt;(2);
let buffer2 = StableBuffer.initPresized&lt;Nat&gt;(2);
StableBuffer.add(buffer, 10);
StableBuffer.add(buffer, 11);
StableBuffer.insert(buffer, 1, 9);
StableBuffer.toArray(buffer) // =&gt; [10, 9, 11]</code></pre>

<p>Runtime: O(size)</p>
<p>Amortized Space: O(1), Worst Case Space: O(size)</p>
</p></div><div class="declaration"><h4 class="function" id="insertBuffer"><code><span class="keyword">public func </span><span class="fnname">insertBuffer</span>&lt;<span class="type">X</span>&gt;(<br/>  <span class="parameter">buffer</span> : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;, <br/>  <span class="parameter">index</span> : <span class="type">Nat</span>, <br/>  <span class="parameter">buffer2</span> : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;<br/>)</code></h4><p><p>Inserts <code>buffer2</code> at <code>index</code>, and shifts all elements to the right of
<code>index</code> over by size2. Traps if <code>index</code> is greater than size.</p>
<pre><code>motoko include=initialize
let buffer1 = StableBuffer.initPresized&lt;Nat&gt;(2);
let buffer2 = StableBuffer.initPresized&lt;Nat&gt;(2);
StableBuffer.add(buffer1, 10);
StableBuffer.add(buffer1, 11);
StableBuffer.add(buffer2, 12);
StableBuffer.add(buffer2, 13);
StableBuffer.insertBuffer(buffer1, 1, buffer2);
StableBuffer.toArray(buffer1) // =&gt; [10, 12, 13, 11]</code></pre>

<p>Runtime: O(size)</p>
<p>Amortized Space: O(1), Worst Case Space: O(size1 + size2)</p>
</p></div><div class="declaration"><h4 class="function" id="sort"><code><span class="keyword">public func </span><span class="fnname">sort</span>&lt;<span class="type">X</span>&gt;(<span class="parameter">buffer</span> : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;, <span class="parameter">compare</span> : (<span class="type">X</span>, <span class="type">X</span>) -&gt; <span class="type">Order.Order</span>)</code></h4><p><p>Sorts the elements in the buffer according to <code>compare</code>.
Sort is deterministic, stable, and in-place.</p>
<pre><code>motoko include=initialize

import Nat &quot;mo:base/Nat&quot;;

StableBuffer.add(buffer, 11);
StableBuffer.add(buffer, 12);
StableBuffer.add(buffer, 10);
StableBuffer.sort(buffer, Nat.compare);
StableBuffer.toArray(buffer) // =&gt; [10, 11, 12]</code></pre>

<p>Runtime: O(size * log(size))</p>
<p>Space: O(size)</p>
</p></div><div class="declaration"><h4 class="function" id="isEmpty"><code><span class="keyword">public func </span><span class="fnname">isEmpty</span>&lt;<span class="type">X</span>&gt;(<span class="parameter">buffer</span> : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;) : <span class="type">Bool</span></code></h4><p><p>Returns true if and only if the buffer is empty.</p>
<p>Example:</p>
<pre><code>motoko include=initialize
StableBuffer.add(buffer, 2);
StableBuffer.add(buffer, 0);
StableBuffer.add(buffer, 3);
StableBuffer.isEmpty(buffer); // =&gt; false</code></pre>

<pre><code>motoko include=initialize
Buffer.isEmpty(buffer); // =&gt; true</code></pre>

<p>Runtime: O(1)</p>
<p>Space: O(1)</p>
</p></div><div class="declaration"><h4 class="function" id="max"><code><span class="keyword">public func </span><span class="fnname">max</span>&lt;<span class="type">X</span>&gt;(<span class="parameter">buffer</span> : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;, <span class="parameter">compare</span> : (<span class="type">X</span>, <span class="type">X</span>) -&gt; <a href="#type.Order"><span class="type">Order</span></a>) : ?<span class="type">X</span></code></h4><p><p>Finds the greatest element in <code>buffer</code> defined by <code>compare</code>.
Returns <code>null</code> if <code>buffer</code> is empty.</p>
<p>Example:</p>
<pre><code>motoko include=initialize
import Nat &quot;mo:base/Nat&quot;;

StableBuffer.add(buffer, 1);
StableBuffer.add(buffer, 2);

StableBuffer.max(buffer, Nat.compare); // =&gt; ?2</code></pre>

<p>Runtime: O(size)</p>
<p>Space: O(1)</p>
<p>*Runtime and space assumes that <code>compare</code> runs in O(1) time and space.</p>
</p></div><div class="declaration"><h4 class="function" id="min"><code><span class="keyword">public func </span><span class="fnname">min</span>&lt;<span class="type">X</span>&gt;(<span class="parameter">buffer</span> : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;, <span class="parameter">compare</span> : (<span class="type">X</span>, <span class="type">X</span>) -&gt; <a href="#type.Order"><span class="type">Order</span></a>) : ?<span class="type">X</span></code></h4><p><p>Finds the least element in <code>buffer</code> defined by <code>compare</code>.
Returns <code>null</code> if <code>buffer</code> is empty.</p>
<p>Example:</p>
<pre><code>motoko include=initialize
import Nat &quot;mo:base/Nat&quot;;

StableBuffer.add(buffer, 1);
StableBuffer.add(buffer, 2);

StableBuffer.min(buffer, Nat.compare); // =&gt; ?1</code></pre>

<p>Runtime: O(size)</p>
<p>Space: O(1)</p>
<p>*Runtime and space assumes that <code>compare</code> runs in O(1) time and space.</p>
</p></div><div class="declaration"><h4 class="function" id="equal"><code><span class="keyword">public func </span><span class="fnname">equal</span>&lt;<span class="type">X</span>&gt;(<br/>  <span class="parameter">buffer1</span> : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;, <br/>  <span class="parameter">buffer2</span> : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;, <br/>  <span class="parameter">equal</span> : (<span class="type">X</span>, <span class="type">X</span>) -&gt; <span class="type">Bool</span><br/>) : <span class="type">Bool</span></code></h4><p><p>Defines equality for two buffers, using <code>equal</code> to recursively compare elements in the
buffers. Returns true iff the two buffers are of the same size, and <code>equal</code>
evaluates to true for every pair of elements in the two buffers of the same
index.</p>
<p>Example:</p>
<pre><code>motoko include=initialize
import Nat &quot;mo:base/Nat&quot;;

let buffer1 = StableBuffer.initPresized&lt;Nat&gt;(2);
StableBuffer.add(buffer1, 1);
StableBuffer.add(buffer1, 2);

let buffer2 = StableBuffer.initPresized&lt;Nat&gt;(5);
StableBuffer.add(buffer2, 1);
StableBuffer.add(buffer2, 2);

StableBuffer.equal(buffer1, buffer2, Nat.equal); // =&gt; true</code></pre>

<p>Runtime: O(size)</p>
<p>Space: O(1)</p>
<p>*Runtime and space assumes that <code>equal</code> runs in O(1) time and space.</p>
</p></div><div class="declaration"><h4 class="function" id="compare"><code><span class="keyword">public func </span><span class="fnname">compare</span>&lt;<span class="type">X</span>&gt;(<br/>  <span class="parameter">buffer1</span> : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;, <br/>  <span class="parameter">buffer2</span> : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;, <br/>  <span class="parameter">compare</span> : (<span class="type">X</span>, <span class="type">X</span>) -&gt; <span class="type">Order.Order</span><br/>) : <span class="type">Order.Order</span></code></h4><p><p>Defines comparison for two buffers, using <code>compare</code> to recursively compare elements in the
buffers. Comparison is defined lexicographically.</p>
<p>Example:</p>
<pre><code>motoko include=initialize
import Nat &quot;mo:base/Nat&quot;;

let buffer1 = StableBuffer.initPresized&lt;Nat&gt;(2);
StableBuffer.add(buffer1, 1);
StableBuffer.add(buffer1, 2);

let buffer2 = StableBuffer.initPresized&lt;Nat&gt;(3);
StableBuffer.add(buffer2, 3);
StableBuffer.add(buffer2, 4);

StableBuffer.compare&lt;Nat&gt;(buffer1, buffer2, Nat.compare); // =&gt; #less</code></pre>

<p>Runtime: O(size)</p>
<p>Space: O(1)</p>
<p>*Runtime and space assumes that <code>compare</code> runs in O(1) time and space.</p>
</p></div><div class="declaration"><h4 class="function" id="toText"><code><span class="keyword">public func </span><span class="fnname">toText</span>&lt;<span class="type">X</span>&gt;(<span class="parameter">buffer</span> : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;, <span class="parameter">toText</span> : <span class="type">X</span> -&gt; <span class="type">Text</span>) : <span class="type">Text</span></code></h4><p><p>Creates a textual representation of <code>buffer</code>, using <code>toText</code> to recursively
convert the elements into Text.</p>
<p>Example:</p>
<pre><code>motoko include=initialize
import Nat &quot;mo:base/Nat&quot;;

StableBuffer.add(buffer, 1);
StableBuffer.add(buffer, 2);
StableBuffer.add(buffer, 3);
StableBuffer.add(buffer, 4);

StableBuffer.toText(buffer, Nat.toText); // =&gt; &quot;[1, 2, 3, 4]&quot;</code></pre>

<p>Runtime: O(size)</p>
<p>Space: O(size)</p>
<p>*Runtime and space assumes that <code>toText</code> runs in O(1) time and space.</p>
</p></div><div class="declaration"><h4 class="function" id="hash"><code><span class="keyword">public func </span><span class="fnname">hash</span>&lt;<span class="type">X</span>&gt;(<span class="parameter">buffer</span> : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;, <span class="parameter">hash</span> : <span class="type">X</span> -&gt; <span class="type">Nat32</span>) : <span class="type">Nat32</span></code></h4><p><p>Hashes <code>buffer</code> using <code>hash</code> to hash the underlying elements.
The deterministic hash function is a function of the elements in the Buffer, as well
as their ordering.</p>
<p>Example:</p>
<pre><code>motoko include=initialize
import Hash &quot;mo:base/Hash&quot;;

StableBuffer.add(buffer, 1);
StableBuffer.add(buffer, 2);
StableBuffer.add(buffer, 3);
StableBuffer.add(buffer, 1000);

StableBuffer.hash&lt;Nat&gt;(buffer, Hash.hash); // =&gt; 2_872_640_342</code></pre>

<p>Runtime: O(size)</p>
<p>Space: O(1)</p>
<p>*Runtime and space assumes that <code>hash</code> runs in O(1) time and space.</p>
</p></div><div class="declaration"><h4 class="function" id="lastIndexOf"><code><span class="keyword">public func </span><span class="fnname">lastIndexOf</span>&lt;<span class="type">X</span>&gt;(<br/>  <span class="parameter">element</span> : <span class="type">X</span>, <br/>  <span class="parameter">buffer</span> : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;, <br/>  <span class="parameter">equal</span> : (<span class="type">X</span>, <span class="type">X</span>) -&gt; <span class="type">Bool</span><br/>) : ?<span class="type">Nat</span></code></h4><p><p>Finds the last index of <code>element</code> in <code>buffer</code> using equality of elements defined
by <code>equal</code>. Returns <code>null</code> if <code>element</code> is not found.</p>
<p>Example:</p>
<pre><code>motoko include=initialize
import Nat &quot;mo:base/Nat&quot;;

StableBuffer.add(buffer, 1);
StableBuffer.add(buffer, 2);
StableBuffer.add(buffer, 3);
StableBuffer.add(buffer, 4);
StableBuffer.add(buffer, 2);
StableBuffer.add(buffer, 2);

StableBuffer.lastIndexOf&lt;Nat&gt;(2, buffer, Nat.equal); // =&gt; ?5</code></pre>

<p>Runtime: O(size)</p>
<p>Space: O(size)</p>
<p>*Runtime and space assumes that <code>equal</code> runs in O(1) time and space.</p>
</p></div><div class="declaration"><h4 class="function" id="indexOfBuffer"><code><span class="keyword">public func </span><span class="fnname">indexOfBuffer</span>&lt;<span class="type">X</span>&gt;(<br/>  <span class="parameter">subBuffer</span> : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;, <br/>  <span class="parameter">buffer</span> : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;, <br/>  <span class="parameter">equal</span> : (<span class="type">X</span>, <span class="type">X</span>) -&gt; <span class="type">Bool</span><br/>) : ?<span class="type">Nat</span></code></h4><p><p>Searches for <code>subBuffer</code> in <code>buffer</code>, and returns the starting index if it is found.</p>
<p>Example:</p>
<pre><code>motoko include=initialize
import Nat &quot;mo:base/Nat&quot;;

StableBuffer.add(buffer, 1);
StableBuffer.add(buffer, 2);
StableBuffer.add(buffer, 3);
StableBuffer.add(buffer, 4);
StableBuffer.add(buffer, 5);
StableBuffer.add(buffer, 6);

let sub = StableBuffer.initPresized&lt;Nat&gt;(2);
StableBuffer.add(sub, 4);
StableBuffer.add(sub, 5);
StableBuffer.add(sub, 6);

StableBuffer.indexOfBuffer&lt;Nat&gt;(sub, buffer, Nat.equal); // =&gt; ?3</code></pre>

<p>Runtime: O(size of buffer + size of subBuffer)</p>
<p>Space: O(size of subBuffer)</p>
<p>*Runtime and space assumes that <code>equal</code> runs in O(1) time and space.</p>
</p></div><div class="declaration"><h4 class="function" id="binarySearch"><code><span class="keyword">public func </span><span class="fnname">binarySearch</span>&lt;<span class="type">X</span>&gt;(<br/>  <span class="parameter">element</span> : <span class="type">X</span>, <br/>  <span class="parameter">buffer</span> : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;, <br/>  <span class="parameter">compare</span> : (<span class="type">X</span>, <span class="type">X</span>) -&gt; <span class="type">Order.Order</span><br/>) : ?<span class="type">Nat</span></code></h4><p><p>Similar to indexOf, but runs in logarithmic time. Assumes that <code>buffer</code> is sorted.
Behavior is undefined if <code>buffer</code> is not sorted. Uses <code>compare</code> to
perform the search. Returns an index of <code>element</code> if it is found.</p>
<p>Example:</p>
<pre><code>motoko include=initialize
import Nat &quot;mo:base/Nat&quot;;

StableBuffer.add(buffer, 1);
StableBuffer.add(buffer, 4);
StableBuffer.add(buffer, 5);
StableBuffer.add(buffer, 6);

StableBuffer.binarySearch&lt;Nat&gt;(5, buffer, Nat.compare); // =&gt; ?2</code></pre>

<p>Runtime: O(log(size))</p>
<p>Space: O(1)</p>
<p>*Runtime and space assumes that <code>compare</code> runs in O(1) time and space.</p>
</p></div><div class="declaration"><h4 class="function" id="subBuffer"><code><span class="keyword">public func </span><span class="fnname">subBuffer</span>&lt;<span class="type">X</span>&gt;(<br/>  <span class="parameter">buffer</span> : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;, <br/>  <span class="parameter">start</span> : <span class="type">Nat</span>, <br/>  <span class="parameter">length</span> : <span class="type">Nat</span><br/>) : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;</code></h4><p><p>Returns the sub-buffer of <code>buffer</code> starting at index <code>start</code>
of length <code>length</code>. Traps if <code>start</code> is out of bounds, or <code>start + length</code>
is greater than the size of <code>buffer</code>.</p>
<p>Example:</p>
<pre><code>motoko include=initialize
import Nat &quot;mo:base/Nat&quot;;

StableBuffer.add(buffer, 1);
StableBuffer.add(buffer, 2);
StableBuffer.add(buffer, 3);
StableBuffer.add(buffer, 4);
StableBuffer.add(buffer, 5);
StableBuffer.add(buffer, 6);

let sub = StableBuffer.subBuffer(buffer, 3, 2);
StableBuffer.toText(sub, Nat.toText); // =&gt; [4, 5]</code></pre>

<p>Runtime: O(length)</p>
<p>Space: O(length)</p>
</p></div><div class="declaration"><h4 class="function" id="isSubBufferOf"><code><span class="keyword">public func </span><span class="fnname">isSubBufferOf</span>&lt;<span class="type">X</span>&gt;(<br/>  <span class="parameter">subBuffer</span> : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;, <br/>  <span class="parameter">buffer</span> : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;, <br/>  <span class="parameter">equal</span> : (<span class="type">X</span>, <span class="type">X</span>) -&gt; <span class="type">Bool</span><br/>) : <span class="type">Bool</span></code></h4><p><p>Checks if <code>subBuffer</code> is a sub-Buffer of <code>buffer</code>. Uses <code>equal</code> to
compare elements.</p>
<p>Example:</p>
<pre><code>motoko include=initialize
import Nat &quot;mo:base/Nat&quot;;

StableBuffer.add(buffer, 1);
StableBuffer.add(buffer, 2);
StableBuffer.add(buffer, 3);
StableBuffer.add(buffer, 4);
StableBuffer.add(buffer, 5);
StableBuffer.add(buffer, 6);

let sub = StableBuffer.initPresized&lt;Nat&gt;(2);
StableBuffer.add(sub, 2);
StableBuffer.add(sub, 3);
StableBuffer.isSubBufferOf(sub, buffer, Nat.equal); // =&gt; true</code></pre>

<p>Runtime: O(size of subBuffer + size of buffer)</p>
<p>Space: O(size of subBuffer)</p>
<p>*Runtime and space assumes that <code>equal</code> runs in O(1) time and space.</p>
</p></div><div class="declaration"><h4 class="function" id="isStrictSubBufferOf"><code><span class="keyword">public func </span><span class="fnname">isStrictSubBufferOf</span>&lt;<span class="type">X</span>&gt;(<br/>  <span class="parameter">subBuffer</span> : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;, <br/>  <span class="parameter">buffer</span> : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;, <br/>  <span class="parameter">equal</span> : (<span class="type">X</span>, <span class="type">X</span>) -&gt; <span class="type">Bool</span><br/>) : <span class="type">Bool</span></code></h4><p><p>Checks if <code>subBuffer</code> is a strict subBuffer of <code>buffer</code>, i.e. <code>subBuffer</code> must be
strictly contained inside both the first and last indices of <code>buffer</code>.
Uses <code>equal</code> to compare elements.</p>
<p>Example:</p>
<pre><code>motoko include=initialize
import Nat &quot;mo:base/Nat&quot;;

StableBuffer.add(buffer, 1);
StableBuffer.add(buffer, 2);
StableBuffer.add(buffer, 3);
StableBuffer.add(buffer, 4);

let sub = StableBuffer.initPresized&lt;Nat&gt;(2);
StableBuffer.add(sub, 2);
StableBuffer.add(sub, 3);
StableBuffer.isStrictSubBufferOf(sub, buffer, Nat.equal); // =&gt; true</code></pre>

<p>Runtime: O(size of subBuffer + size of buffer)</p>
<p>Space: O(size of subBuffer)</p>
<p>*Runtime and space assumes that <code>equal</code> runs in O(1) time and space.</p>
</p></div><div class="declaration"><h4 class="function" id="prefix"><code><span class="keyword">public func </span><span class="fnname">prefix</span>&lt;<span class="type">X</span>&gt;(<span class="parameter">buffer</span> : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;, <span class="parameter">length</span> : <span class="type">Nat</span>) : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;</code></h4><p><p>Returns the prefix of <code>buffer</code> of length <code>length</code>. Traps if <code>length</code>
is greater than the size of <code>buffer</code>.</p>
<p>Example:</p>
<pre><code>motoko include=initialize
import Nat &quot;mo:base/Nat&quot;;

StableBuffer.add(buffer, 1);
StableBuffer.add(buffer, 2);
StableBuffer.add(buffer, 3);
StableBuffer.add(buffer, 4);

let pre = StableBuffer.prefix(buffer, 3); // =&gt; [1, 2, 3]
StableBuffer.toText(pre, Nat.toText);</code></pre>

<p>Runtime: O(length)</p>
<p>Space: O(length)</p>
</p></div><div class="declaration"><h4 class="function" id="isPrefixOf"><code><span class="keyword">public func </span><span class="fnname">isPrefixOf</span>&lt;<span class="type">X</span>&gt;(<br/>  <span class="parameter">prefix</span> : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;, <br/>  <span class="parameter">buffer</span> : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;, <br/>  <span class="parameter">equal</span> : (<span class="type">X</span>, <span class="type">X</span>) -&gt; <span class="type">Bool</span><br/>) : <span class="type">Bool</span></code></h4><p><p>Checks if <code>prefix</code> is a prefix of <code>buffer</code>. Uses <code>equal</code> to
compare elements.</p>
<p>Example:</p>
<pre><code>motoko include=initialize
import Nat &quot;mo:base/Nat&quot;;

StableBuffer.add(buffer, 1);
StableBuffer.add(buffer, 2);
StableBuffer.add(buffer, 3);
StableBuffer.add(buffer, 4);

let pre = StableBuffer.initPresized&lt;Nat&gt;(2);
StableBuffer.add(pre, 1);
StableBuffer.add(pre, 2);
StableBuffer.isPrefixOf(pre, buffer, Nat.equal); // =&gt; true</code></pre>

<p>Runtime: O(size of prefix)</p>
<p>Space: O(size of prefix)</p>
<p>*Runtime and space assumes that <code>equal</code> runs in O(1) time and space.</p>
</p></div><div class="declaration"><h4 class="function" id="isStrictPrefixOf"><code><span class="keyword">public func </span><span class="fnname">isStrictPrefixOf</span>&lt;<span class="type">X</span>&gt;(<br/>  <span class="parameter">prefix</span> : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;, <br/>  <span class="parameter">buffer</span> : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;, <br/>  <span class="parameter">equal</span> : (<span class="type">X</span>, <span class="type">X</span>) -&gt; <span class="type">Bool</span><br/>) : <span class="type">Bool</span></code></h4><p><p>Checks if <code>prefix</code> is a strict prefix of <code>buffer</code>. Uses <code>equal</code> to
compare elements.</p>
<p>Example:</p>
<pre><code>motoko include=initialize
import Nat &quot;mo:base/Nat&quot;;

StableBuffer.add(buffer, 1);
StableBuffer.add(buffer, 2);
StableBuffer.add(buffer, 3);
StableBuffer.add(buffer, 4);

let pre = StableBuffer.initPresized&lt;Nat&gt;(3);
StableBuffer.add(pre, 1);
StableBuffer.add(pre, 2);
StableBuffer.add(pre, 3);
StableBuffer.isStrictPrefixOf(pre, buffer, Nat.equal); // =&gt; true</code></pre>

<p>Runtime: O(size of prefix)</p>
<p>Space: O(size of prefix)</p>
<p>*Runtime and space assumes that <code>equal</code> runs in O(1) time and space.</p>
</p></div><div class="declaration"><h4 class="function" id="suffix"><code><span class="keyword">public func </span><span class="fnname">suffix</span>&lt;<span class="type">X</span>&gt;(<span class="parameter">buffer</span> : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;, <span class="parameter">length</span> : <span class="type">Nat</span>) : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;</code></h4><p><p>Returns the suffix of <code>buffer</code> of length <code>length</code>.
Traps if <code>length</code>is greater than the size of <code>buffer</code>.</p>
<p>Example:</p>
<pre><code>motoko include=initialize
import Nat &quot;mo:base/Nat&quot;;

StableBuffer.add(buffer, 1);
StableBuffer.add(buffer, 2);
StableBuffer.add(buffer, 3);
StableBuffer.add(buffer, 4);

let suf = StableBuffer.suffix(buffer, 3); // =&gt; [2, 3, 4]
StableBuffer.toText(suf, Nat.toText);</code></pre>

<p>Runtime: O(length)</p>
<p>Space: O(length)</p>
</p></div><div class="declaration"><h4 class="function" id="isSuffixOf"><code><span class="keyword">public func </span><span class="fnname">isSuffixOf</span>&lt;<span class="type">X</span>&gt;(<br/>  <span class="parameter">suffix</span> : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;, <br/>  <span class="parameter">buffer</span> : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;, <br/>  <span class="parameter">equal</span> : (<span class="type">X</span>, <span class="type">X</span>) -&gt; <span class="type">Bool</span><br/>) : <span class="type">Bool</span></code></h4><p><p>Checks if <code>suffix</code> is a suffix of <code>buffer</code>. Uses <code>equal</code> to compare
elements.</p>
<p>Example:</p>
<pre><code>motoko include=initialize
import Nat &quot;mo:base/Nat&quot;;

StableBuffer.add(buffer, 1);
StableBuffer.add(buffer, 2);
StableBuffer.add(buffer, 3);
StableBuffer.add(buffer, 4);

let suf = StableBuffer.initPresized&lt;Nat&gt;(3);
StableBuffer.add(suf, 2);
StableBuffer.add(suf, 3);
StableBuffer.add(suf, 4);
StableBuffer.isSuffixOf(suf, buffer, Nat.equal); // =&gt; true</code></pre>

<p>Runtime: O(length of suffix)</p>
<p>Space: O(length of suffix)</p>
<p>*Runtime and space assumes that <code>equal</code> runs in O(1) time and space.</p>
</p></div><div class="declaration"><h4 class="function" id="isStrictSuffixOf"><code><span class="keyword">public func </span><span class="fnname">isStrictSuffixOf</span>&lt;<span class="type">X</span>&gt;(<br/>  <span class="parameter">suffix</span> : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;, <br/>  <span class="parameter">buffer</span> : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;, <br/>  <span class="parameter">equal</span> : (<span class="type">X</span>, <span class="type">X</span>) -&gt; <span class="type">Bool</span><br/>) : <span class="type">Bool</span></code></h4><p><p>Checks if <code>suffix</code> is a strict suffix of <code>buffer</code>. Uses <code>equal</code> to compare
elements.</p>
<p>Example:</p>
<pre><code>motoko include=initialize
import Nat &quot;mo:base/Nat&quot;;

StableBuffer.add(buffer, 1);
StableBuffer.add(buffer, 2);
StableBuffer.add(buffer, 3);
StableBuffer.add(buffer, 4);

let suf = StableBuffer.initPresized&lt;Nat&gt;(3);
StableBuffer.add(suf, 2);
StableBuffer.add(suf, 3);
StableBuffer.add(suf, 4);
StableBuffer.isStrictSuffixOf(suf, buffer, Nat.equal); // =&gt; true</code></pre>

<p>Runtime: O(length of suffix)</p>
<p>Space: O(length of suffix)</p>
<p>*Runtime and space assumes that <code>equal</code> runs in O(1) time and space.</p>
</p></div><div class="declaration"><h4 class="function" id="forAll"><code><span class="keyword">public func </span><span class="fnname">forAll</span>&lt;<span class="type">X</span>&gt;(<span class="parameter">buffer</span> : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;, <span class="parameter">predicate</span> : <span class="type">X</span> -&gt; <span class="type">Bool</span>) : <span class="type">Bool</span></code></h4><p><p>Returns true iff every element in <code>buffer</code> satisfies <code>predicate</code>.</p>
<p>Example:</p>
<pre><code>motoko include=initialize

StableBuffer.add(buffer, 2);
StableBuffer.add(buffer, 3);
StableBuffer.add(buffer, 4);

StableBuffer.forAll&lt;Nat&gt;(buffer, func x { x &gt; 1 }); // =&gt; true</code></pre>

<p>Runtime: O(size)</p>
<p>Space: O(1)</p>
<p>*Runtime and space assumes that <code>predicate</code> runs in O(1) time and space.</p>
</p></div><div class="declaration"><h4 class="function" id="forSome"><code><span class="keyword">public func </span><span class="fnname">forSome</span>&lt;<span class="type">X</span>&gt;(<span class="parameter">buffer</span> : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;, <span class="parameter">predicate</span> : <span class="type">X</span> -&gt; <span class="type">Bool</span>) : <span class="type">Bool</span></code></h4><p><p>Returns true iff some element in <code>buffer</code> satisfies <code>predicate</code>.</p>
<p>Example:</p>
<pre><code>motoko include=initialize

StableBuffer.add(buffer, 2);
StableBuffer.add(buffer, 3);
StableBuffer.add(buffer, 4);

StableBuffer.forSome&lt;Nat&gt;(buffer, func x { x &gt; 3 }); // =&gt; true</code></pre>

<p>Runtime: O(size)</p>
<p>Space: O(1)</p>
<p>*Runtime and space assumes that <code>predicate</code> runs in O(1) time and space.</p>
</p></div><div class="declaration"><h4 class="function" id="forNone"><code><span class="keyword">public func </span><span class="fnname">forNone</span>&lt;<span class="type">X</span>&gt;(<span class="parameter">buffer</span> : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;, <span class="parameter">predicate</span> : <span class="type">X</span> -&gt; <span class="type">Bool</span>) : <span class="type">Bool</span></code></h4><p><p>Returns true iff no element in <code>buffer</code> satisfies <code>predicate</code>.</p>
<p>Example:</p>
<pre><code>motoko include=initialize

StableBuffer.add(buffer, 2);
StableBuffer.add(buffer, 3);
StableBuffer.add(buffer, 4);

StableBuffer.forNone&lt;Nat&gt;(buffer, func x { x == 0 }); // =&gt; true</code></pre>

<p>Runtime: O(size)</p>
<p>Space: O(1)</p>
<p>*Runtime and space assumes that <code>predicate</code> runs in O(1) time and space.</p>
</p></div><div class="declaration"><h4 class="function" id="fromVarArray"><code><span class="keyword">public func </span><span class="fnname">fromVarArray</span>&lt;<span class="type">X</span>&gt;(<span class="parameter">array</span> : [<span class="keyword">var </span><span class="type">X</span>]) : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;</code></h4><p><p>Creates a buffer containing elements from <code>array</code>.</p>
<p>Example:</p>
<pre><code>motoko include=initialize
import Nat &quot;mo:base/Nat&quot;;

let array = [var 1, 2, 3];

let buf = StableBuffer.fromVarArray&lt;Nat&gt;(array); // =&gt; [1, 2, 3]
StableBuffer.toText(buf, Nat.toText);</code></pre>

<p>Runtime: O(size)</p>
<p>Space: O(size)</p>
</p></div><div class="declaration"><h4 class="function" id="fromIter"><code><span class="keyword">public func </span><span class="fnname">fromIter</span>&lt;<span class="type">X</span>&gt;(<span class="parameter">iter</span> : { next : () -&gt; ?<span class="type">X</span> }) : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;</code></h4><p><p>Creates a buffer containing elements from <code>iter</code>.</p>
<p>Example:</p>
<pre><code>motoko include=initialize
import Nat &quot;mo:base/Nat&quot;;

let array = [1, 1, 1];
let iter = array.vals();

let buf = StableBuffer.fromIter&lt;Nat&gt;(iter); // =&gt; [1, 1, 1]
StableBuffer.toText(buf, Nat.toText);</code></pre>

<p>Runtime: O(size)</p>
<p>Space: O(size)</p>
</p></div><div class="declaration"><h4 class="function" id="trimToSize"><code><span class="keyword">public func </span><span class="fnname">trimToSize</span>&lt;<span class="type">X</span>&gt;(<span class="parameter">buffer</span> : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;)</code></h4><p><p>Reallocates the array underlying <code>buffer</code> such that capacity == size.</p>
<p>Example:</p>
<pre><code>motoko include=initialize

let buffer = StableBuffer.initPresized&lt;Nat&gt;(10);
StableBuffer.add(buffer, 1);
StableBuffer.add(buffer, 2);
StableBuffer.add(buffer, 3);

StableBuffer.trimToSize&lt;Nat&gt;(buffer);
StableBuffer.capacity(buffer); // =&gt; 3</code></pre>

<p>Runtime: O(size)</p>
<p>Space: O(size)</p>
</p></div><div class="declaration"><h4 class="function" id="map"><code><span class="keyword">public func </span><span class="fnname">map</span>&lt;<span class="type">X</span>, <span class="type">Y</span>&gt;(<span class="parameter">buffer</span> : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;, <span class="parameter">f</span> : <span class="type">X</span> -&gt; <span class="type">Y</span>) : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">Y</span>&gt;</code></h4><p><p>Creates a new buffer by applying <code>f</code> to each element in <code>buffer</code>.</p>
<p>Example:</p>
<pre><code>motoko include=initialize
import Nat &quot;mo:base/Nat&quot;;

StableBuffer.add(buffer, 1);
StableBuffer.add(buffer, 2);
StableBuffer.add(buffer, 3);

let newBuf = StableBuffer.map&lt;Nat, Nat&gt;(buffer, func (x) { x + 1 });
StableBuffer.toText(newBuf, Nat.toText); // =&gt; [2, 3, 4]</code></pre>

<p>Runtime: O(size)</p>
<p>Space: O(size)</p>
<p>*Runtime and space assumes that <code>f</code> runs in O(1) time and space.</p>
</p></div><div class="declaration"><h4 class="function" id="iterate"><code><span class="keyword">public func </span><span class="fnname">iterate</span>&lt;<span class="type">X</span>&gt;(<span class="parameter">buffer</span> : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;, <span class="parameter">f</span> : <span class="type">X</span> -&gt; ())</code></h4><p><p>Applies <code>f</code> to each element in <code>buffer</code>.</p>
<p>Example:</p>
<pre><code>motoko include=initialize
import Nat &quot;mo:base/Nat&quot;;
import Debug &quot;mo:base/Debug&quot;;

StableBuffer.add(buffer, 1);
StableBuffer.add(buffer, 2);
StableBuffer.add(buffer, 3);

StableBuffer.iterate&lt;Nat&gt;(buffer, func (x) {
  Debug.print(Nat.toText(x)); // prints each element in buffer
});</code></pre>

<p>Runtime: O(size)</p>
<p>Space: O(size)</p>
<p>*Runtime and space assumes that <code>f</code> runs in O(1) time and space.</p>
</p></div><div class="declaration"><h4 class="function" id="mapEntries"><code><span class="keyword">public func </span><span class="fnname">mapEntries</span>&lt;<span class="type">X</span>, <span class="type">Y</span>&gt;(<span class="parameter">buffer</span> : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;, <span class="parameter">f</span> : (<span class="type">Nat</span>, <span class="type">X</span>) -&gt; <span class="type">Y</span>) : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">Y</span>&gt;</code></h4><p><p>Applies <code>f</code> to each element in <code>buffer</code> and its index.</p>
<p>Example:</p>
<pre><code>motoko include=initialize
import Nat &quot;mo:base/Nat&quot;;

StableBuffer.add(buffer, 1);
StableBuffer.add(buffer, 2);
StableBuffer.add(buffer, 3);

let newBuf = StableBuffer.mapEntries&lt;Nat, Nat&gt;(buffer, func (x, i) { x + i + 1 });
StableBuffer.toText(newBuf, Nat.toText); // =&gt; [2, 4, 6]</code></pre>

<p>Runtime: O(size)</p>
<p>Space: O(size)</p>
<p>*Runtime and space assumes that <code>f</code> runs in O(1) time and space.</p>
</p></div><div class="declaration"><h4 class="function" id="mapFilter"><code><span class="keyword">public func </span><span class="fnname">mapFilter</span>&lt;<span class="type">X</span>, <span class="type">Y</span>&gt;(<span class="parameter">buffer</span> : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;, <span class="parameter">f</span> : <span class="type">X</span> -&gt; ?<span class="type">Y</span>) : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">Y</span>&gt;</code></h4><p><p>Creates a new buffer by applying <code>f</code> to each element in <code>buffer</code>,
and keeping all non-null elements.</p>
<p>Example:</p>
<pre><code>motoko include=initialize
import Nat &quot;mo:base/Nat&quot;;

StableBuffer.add(buffer, 1);
StableBuffer.add(buffer, 2);
StableBuffer.add(buffer, 3);

let newBuf = StableBuffer.mapFilter&lt;Nat, Nat&gt;(buffer, func (x) {
  if (x &gt; 1) {
    ?(x * 2);
  } else {
    null;
  }
});
StableBuffer.toText(newBuf, Nat.toText); // =&gt; [4, 6]</code></pre>

<p>Runtime: O(size)</p>
<p>Space: O(size)</p>
<p>*Runtime and space assumes that <code>f</code> runs in O(1) time and space.</p>
</p></div><div class="declaration"><h4 class="function" id="mapResult"><code><span class="keyword">public func </span><span class="fnname">mapResult</span>&lt;<span class="type">X</span>, <span class="type">Y</span>, <span class="type">E</span>&gt;(<span class="parameter">buffer</span> : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;, <span class="parameter">f</span> : <span class="type">X</span> -&gt; <span class="type">Result.Result</span>&lt;<span class="type">Y</span>, <span class="type">E</span>&gt;) : <span class="type">Result.Result</span>&lt;<a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">Y</span>&gt;, <span class="type">E</span>&gt;</code></h4><p><p>Creates a new buffer by applying <code>f</code> to each element in <code>buffer</code>.
If any invocation of <code>f</code> produces an <code>#err</code>, returns an <code>#err</code>. Otherwise
Returns an <code>#ok</code> containing the new buffer.</p>
<p>Example:</p>
<pre><code>motoko include=initialize
import Result &quot;mo:base/Result&quot;;

StableBuffer.add(buffer, 1);
StableBuffer.add(buffer, 2);
StableBuffer.add(buffer, 3);

let result = StableBuffer.mapResult&lt;Nat, Nat, Text&gt;(buffer, func (k) {
  if (k &gt; 0) {
    #ok(k);
  } else {
    #err(&quot;One or more elements are zero.&quot;);
  }
});

Result.mapOk&lt;StableBuffer.StableBuffer&lt;Nat&gt;, [Nat], Text&gt;(result, func buffer = StableBuffer.toArray(buffer)) // =&gt; #ok([1, 2, 3])</code></pre>

<p>Runtime: O(size)</p>
<p>Space: O(size)</p>
<p>*Runtime and space assumes that <code>f</code> runs in O(1) time and space.</p>
</p></div><div class="declaration"><h4 class="function" id="chain"><code><span class="keyword">public func </span><span class="fnname">chain</span>&lt;<span class="type">X</span>, <span class="type">Y</span>&gt;(<span class="parameter">buffer</span> : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;, <span class="parameter">k</span> : <span class="type">X</span> -&gt; <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">Y</span>&gt;) : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">Y</span>&gt;</code></h4><p><p>Creates a new buffer by applying <code>k</code> to each element in <code>buffer</code>,
and concatenating the resulting buffers in order. This operation
is similar to what in other functional languages is known as monadic bind.</p>
<p>Example:</p>
<pre><code>motoko include=initialize
import Nat &quot;mo:base/Nat&quot;;

StableBuffer.add(buffer, 1);
StableBuffer.add(buffer, 2);
StableBuffer.add(buffer, 3);

let chain = StableBuffer.chain&lt;Nat, Nat&gt;(buffer, func (x) {
  let b = StableBuffer.initPresized&lt;Nat&gt;(2);
  b.add(x);
  b.add(x * 2);
  return b;
});
Buffer.toText(chain, Nat.toText); // =&gt; [1, 2, 2, 4, 3, 6]</code></pre>

<p>Runtime: O(size)</p>
<p>Space: O(size)</p>
<p>*Runtime and space assumes that <code>k</code> runs in O(1) time and space.</p>
</p></div><div class="declaration"><h4 class="function" id="foldLeft"><code><span class="keyword">public func </span><span class="fnname">foldLeft</span>&lt;<span class="type">A</span>, <span class="type">X</span>&gt;(<br/>  <span class="parameter">buffer</span> : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;, <br/>  <span class="parameter">base</span> : <span class="type">A</span>, <br/>  <span class="parameter">combine</span> : (<span class="type">A</span>, <span class="type">X</span>) -&gt; <span class="type">A</span><br/>) : <span class="type">A</span></code></h4><p><p>Collapses the elements in <code>buffer</code> into a single value by starting with <code>base</code>
and progessively combining elements into <code>base</code> with <code>combine</code>. Iteration runs
left to right.</p>
<p>Example:</p>
<pre><code>motoko include=initialize
import Nat &quot;mo:base/Nat&quot;;

buffer.add(1);
buffer.add(2);
buffer.add(3);

Buffer.foldLeft&lt;Text, Nat&gt;(buffer, &quot;&quot;, func (acc, x) { acc # Nat.toText(x)}); // =&gt; &quot;123&quot;</code></pre>

<p>Runtime: O(size)</p>
<p>Space: O(1)</p>
<p>*Runtime and space assumes that <code>combine</code> runs in O(1) time and space.</p>
</p></div><div class="declaration"><h4 class="function" id="foldRight"><code><span class="keyword">public func </span><span class="fnname">foldRight</span>&lt;<span class="type">X</span>, <span class="type">A</span>&gt;(<br/>  <span class="parameter">buffer</span> : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;, <br/>  <span class="parameter">base</span> : <span class="type">A</span>, <br/>  <span class="parameter">combine</span> : (<span class="type">X</span>, <span class="type">A</span>) -&gt; <span class="type">A</span><br/>) : <span class="type">A</span></code></h4><p><p>Collapses the elements in <code>buffer</code> into a single value by starting with <code>base</code>
and progessively combining elements into <code>base</code> with <code>combine</code>. Iteration runs
right to left.</p>
<p>Example:</p>
<pre><code>motoko include=initialize
import Nat &quot;mo:base/Nat&quot;;

buffer.add(1);
buffer.add(2);
buffer.add(3);

Buffer.foldRight&lt;Nat, Text&gt;(buffer, &quot;&quot;, func (x, acc) { Nat.toText(x) # acc }); // =&gt; &quot;123&quot;</code></pre>

<p>Runtime: O(size)</p>
<p>Space: O(1)</p>
<p>*Runtime and space assumes that <code>combine</code> runs in O(1) time and space.</p>
</p></div><div class="declaration"><h4 class="function" id="first"><code><span class="keyword">public func </span><span class="fnname">first</span>&lt;<span class="type">X</span>&gt;(<span class="parameter">buffer</span> : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;) : <span class="type">X</span></code></h4><p><p>Returns the first element of <code>buffer</code>. Traps if <code>buffer</code> is empty.</p>
<p>Example:</p>
<pre><code>motoko include=initialize

buffer.add(1);
buffer.add(2);
buffer.add(3);

Buffer.first(buffer); // =&gt; 1</code></pre>

<p>Runtime: O(1)</p>
<p>Space: O(1)</p>
</p></div><div class="declaration"><h4 class="function" id="last"><code><span class="keyword">public func </span><span class="fnname">last</span>&lt;<span class="type">X</span>&gt;(<span class="parameter">buffer</span> : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;) : <span class="type">X</span></code></h4><p><p>Returns the last element of <code>buffer</code>. Traps if <code>buffer</code> is empty.</p>
<p>Example:</p>
<pre><code>motoko include=initialize

buffer.add(1);
buffer.add(2);
buffer.add(3);

Buffer.last(buffer); // =&gt; 3</code></pre>

<p>Runtime: O(1)</p>
<p>Space: O(1)</p>
</p></div><div class="declaration"><h4 class="function" id="make"><code><span class="keyword">public func </span><span class="fnname">make</span>&lt;<span class="type">X</span>&gt;(<span class="parameter">element</span> : <span class="type">X</span>) : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;</code></h4><p><p>Returns a new buffer with capacity and size 1, containing <code>element</code>.</p>
<p>Example:</p>
<pre><code>motoko include=initialize
import Nat &quot;mo:base/Nat&quot;;

let buffer = Buffer.make&lt;Nat&gt;(1);
Buffer.toText(buffer, Nat.toText); // =&gt; [1]</code></pre>

<p>Runtime: O(1)</p>
<p>Space: O(1)</p>
</p></div><div class="declaration"><h4 class="function" id="reverse"><code><span class="keyword">public func </span><span class="fnname">reverse</span>&lt;<span class="type">X</span>&gt;(<span class="parameter">buffer</span> : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;)</code></h4><p><p>Reverses the order of elements in <code>buffer</code>.</p>
<p>Example:</p>
<pre><code>motoko include=initialize
import Nat &quot;mo:base/Nat&quot;;

buffer.add(1);
buffer.add(2);
buffer.add(3);

Buffer.reverse(buffer);
Buffer.toText(buffer, Nat.toText); // =&gt; [3, 2, 1]</code></pre>

<p>Runtime: O(size)</p>
<p>Space: O(1)</p>
</p></div><div class="declaration"><h4 class="function" id="merge"><code><span class="keyword">public func </span><span class="fnname">merge</span>&lt;<span class="type">X</span>&gt;(<br/>  <span class="parameter">buffer1</span> : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;, <br/>  <span class="parameter">buffer2</span> : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;, <br/>  <span class="parameter">compare</span> : (<span class="type">X</span>, <span class="type">X</span>) -&gt; <a href="#type.Order"><span class="type">Order</span></a><br/>) : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;</code></h4><p><p>Merges two sorted buffers into a single sorted buffer, using <code>compare</code> to define
the ordering. The final ordering is stable. Behavior is undefined if either
<code>buffer1</code> or <code>buffer2</code> is not sorted.</p>
<p>Example:</p>
<pre><code>motoko include=initialize
import Nat &quot;mo:base/Nat&quot;;

let buffer1 = Buffer.Buffer&lt;Nat&gt;(2);
buffer1.add(1);
buffer1.add(2);
buffer1.add(4);

let buffer2 = Buffer.Buffer&lt;Nat&gt;(2);
buffer2.add(2);
buffer2.add(4);
buffer2.add(6);

let merged = Buffer.merge&lt;Nat&gt;(buffer1, buffer2, Nat.compare);
Buffer.toText(merged, Nat.toText); // =&gt; [1, 2, 2, 4, 4, 6]</code></pre>

<p>Runtime: O(size1 + size2)</p>
<p>Space: O(size1 + size2)</p>
<p>*Runtime and space assumes that <code>compare</code> runs in O(1) time and space.</p>
</p></div><div class="declaration"><h4 class="function" id="removeDuplicates"><code><span class="keyword">public func </span><span class="fnname">removeDuplicates</span>&lt;<span class="type">X</span>&gt;(<span class="parameter">buffer</span> : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;, <span class="parameter">compare</span> : (<span class="type">X</span>, <span class="type">X</span>) -&gt; <a href="#type.Order"><span class="type">Order</span></a>)</code></h4><p><p>Eliminates all duplicate elements in <code>buffer</code> as defined by <code>compare</code>.
Elimination is stable with respect to the original ordering of the elements.</p>
<p>Example:</p>
<pre><code>motoko include=initialize
import Nat &quot;mo:base/Nat&quot;;

buffer.add(1);
buffer.add(2);
buffer.add(3);
buffer.add(1);
buffer.add(2);
buffer.add(3);

Buffer.removeDuplicates&lt;Nat&gt;(buffer, Nat.compare);
Buffer.toText(buffer, Nat.toText); // =&gt; [1, 2, 3]</code></pre>

<p>Runtime: O(size * log(size))</p>
<p>Space: O(size)</p>
</p></div><div class="declaration"><h4 class="function" id="partition"><code><span class="keyword">public func </span><span class="fnname">partition</span>&lt;<span class="type">X</span>&gt;(<span class="parameter">buffer</span> : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;, <span class="parameter">predicate</span> : <span class="type">X</span> -&gt; <span class="type">Bool</span>) : (<a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;, <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;)</code></h4><p><p>Splits <code>buffer</code> into a pair of buffers where all elements in the left
buffer satisfy <code>predicate</code> and all elements in the right buffer do not.</p>
<p>Example:</p>
<pre><code>motoko include=initialize
import Nat &quot;mo:base/Nat&quot;;

StableBuffer.add(buffer, 1);
StableBuffer.add(buffer, 2);
StableBuffer.add(buffer, 3);
StableBuffer.add(buffer, 4);
StableBuffer.add(buffer, 5);
StableBuffer.add(buffer, 6);

let partitions = StableBuffer.partition&lt;Nat&gt;(buffer, func (x) { x % 2 == 0 });
(StableBuffer.toArray(partitions.0), StableBuffer.toArray(partitions.1)) // =&gt; ([2, 4, 6], [1, 3, 5])</code></pre>

<p>Runtime: O(size)</p>
<p>Space: O(size)</p>
<p>*Runtime and space assumes that <code>predicate</code> runs in O(1) time and space.</p>
</p></div><div class="declaration"><h4 class="function" id="split"><code><span class="keyword">public func </span><span class="fnname">split</span>&lt;<span class="type">X</span>&gt;(<span class="parameter">buffer</span> : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;, <span class="parameter">index</span> : <span class="type">Nat</span>) : (<a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;, <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;)</code></h4><p><p>Splits the buffer into two buffers at <code>index</code>, where the left buffer contains
all elements with indices less than <code>index</code>, and the right buffer contains all
elements with indices greater than or equal to <code>index</code>. Traps if <code>index</code> is out
of bounds.</p>
<p>Example:</p>
<pre><code>motoko include=initialize
import Nat &quot;mo:base/Nat&quot;;

StableBuffer.add(buffer, 1);
StableBuffer.add(buffer, 2);
StableBuffer.add(buffer, 3);
StableBuffer.add(buffer, 4);
StableBuffer.add(buffer, 5);
StableBuffer.add(buffer, 6);

let split = Buffer.split&lt;Nat&gt;(buffer, 3);
(Buffer.toArray(split.0), Buffer.toArray(split.1)) // =&gt; ([1, 2, 3], [4, 5, 6])</code></pre>

<p>Runtime: O(size)</p>
<p>Space: O(size)</p>
<p>*Runtime and space assumes that <code>compare</code> runs in O(1) time and space.</p>
</p></div><div class="declaration"><h4 class="function" id="chunk"><code><span class="keyword">public func </span><span class="fnname">chunk</span>&lt;<span class="type">X</span>&gt;(<span class="parameter">buffer</span> : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;, <span class="parameter">count</span> : <span class="type">Nat</span>) : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;&gt;</code></h4><p><p>Breaks up <code>buffer</code> into buffers of size <code>size</code>. The last chunk may
have less than <code>size</code> elements if the number of elements is not divisible
by the chunk size.</p>
<p>Example:</p>
<pre><code>motoko include=initialize
import Nat &quot;mo:base/Nat&quot;;

StableBuffer.add(buffer, 1);
StableBuffer.add(buffer, 2);
StableBuffer.add(buffer, 3);
StableBuffer.add(buffer, 4);
StableBuffer.add(buffer, 5);
StableBuffer.add(buffer, 6);

let chunks = StableBuffer.chunk&lt;Nat&gt;(buffer, 3);
StableBuffer.toText&lt;StableBuffer.StableBuffer&lt;Nat&gt;&gt;(chunks, func buf = StableBuffer.toText(buf, Nat.toText)); // =&gt; [[1, 2, 3], [4, 5, 6]]</code></pre>

<p>Runtime: O(number of elements in buffer)</p>
<p>Space: O(number of elements in buffer)</p>
</p></div><div class="declaration"><h4 class="function" id="groupBy"><code><span class="keyword">public func </span><span class="fnname">groupBy</span>&lt;<span class="type">X</span>&gt;(<span class="parameter">buffer</span> : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;, <span class="parameter">equal</span> : (<span class="type">X</span>, <span class="type">X</span>) -&gt; <span class="type">Bool</span>) : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;&gt;</code></h4><p><p>Groups equal and adjacent elements in the list into sub lists.</p>
<p>Example:</p>
<pre><code>motoko include=initialize
import Nat &quot;mo:base/Nat&quot;;

StableBuffer.add(buffer, 1);
StableBuffer.add(buffer, 2);
StableBuffer.add(buffer, 2);
StableBuffer.add(buffer, 4);
StableBuffer.add(buffer, 5);
StableBuffer.add(buffer, 5);

let grouped = StableBuffer.groupBy&lt;Nat&gt;(buffer, func (x, y) { x == y });
StableBuffer.toText&lt;StableBuffer.StableBuffer&lt;Nat&gt;&gt;(grouped, func buf = StableBuffer.toText(buf, Nat.toText)); // =&gt; [[1], [2, 2], [4], [5, 5]]</code></pre>

<p>Runtime: O(size)</p>
<p>Space: O(size)</p>
<p>*Runtime and space assumes that <code>equal</code> runs in O(1) time and space.</p>
</p></div><div class="declaration"><h4 class="function" id="flatten"><code><span class="keyword">public func </span><span class="fnname">flatten</span>&lt;<span class="type">X</span>&gt;(<span class="parameter">buffer</span> : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;&gt;) : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;</code></h4><p><p>Flattens the buffer of buffers into a single buffer.</p>
<p>Example:</p>
<pre><code>motoko include=initialize
import Nat &quot;mo:base/Nat&quot;;

let buffer = StableBuffer.initPresized&lt;StableBuffer.StableBuffer&lt;Nat&gt;&gt;(1);

let inner1 = StableBuffer.initPresized&lt;Nat&gt;(2);
StableBuffer.add(inner1, 1);
StableBuffer.add(inner1, 2);

let inner2 = StableBuffer.initPresized&lt;Nat&gt;(2);
StableBuffer.add(inner2, 3);
StableBuffer.add(inner2, 4);

StableBuffer.add(buffer, inner1);
StableBuffer.add(buffer, inner2);
// buffer = [[1, 2], [3, 4]]

let flat = StableBuffer.flatten&lt;Nat&gt;(buffer);
StableBuffer.toText&lt;Nat&gt;(flat, Nat.toText); // =&gt; [1, 2, 3, 4]</code></pre>

<p>Runtime: O(number of elements in buffer)</p>
<p>Space: O(number of elements in buffer)</p>
</p></div><div class="declaration"><h4 class="function" id="zip"><code><span class="keyword">public func </span><span class="fnname">zip</span>&lt;<span class="type">X</span>, <span class="type">Y</span>&gt;(<span class="parameter">buffer1</span> : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;, <span class="parameter">buffer2</span> : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">Y</span>&gt;) : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;(<span class="type">X</span>, <span class="type">Y</span>)&gt;</code></h4><p><p>Combines the two buffers into a single buffer of pairs, pairing together
elements with the same index. If one buffer is longer than the other, the
remaining elements from the longer buffer are not included.</p>
<p>Example:</p>
<pre><code>motoko include=initialize

let buffer1 = StableBuffer.initPresized&lt;Nat&gt;(2);
StableBuffer.add(buffer1, 1);
StableBuffer.add(buffer1, 2);
StableBuffer.add(buffer1, 3);

let buffer2 = StableBuffer.initPresized&lt;Nat&gt;(2);
StableBuffer.add(buffer2, 4);
StableBuffer.add(buffer2, 5);

let zipped = StableBuffer.zip(buffer1, buffer2);
StableBuffer.toArray(zipped); // =&gt; [(1, 4), (2, 5)]</code></pre>

<p>Runtime: O(min(size1, size2))</p>
<p>Space: O(min(size1, size2))</p>
</p></div><div class="declaration"><h4 class="function" id="zipWith"><code><span class="keyword">public func </span><span class="fnname">zipWith</span>&lt;<span class="type">X</span>, <span class="type">Y</span>, <span class="type">Z</span>&gt;(<br/>  <span class="parameter">buffer1</span> : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;, <br/>  <span class="parameter">buffer2</span> : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">Y</span>&gt;, <br/>  <span class="parameter">zip</span> : (<span class="type">X</span>, <span class="type">Y</span>) -&gt; <span class="type">Z</span><br/>) : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">Z</span>&gt;</code></h4><p><p>Combines the two buffers into a single buffer, pairing together
elements with the same index and combining them using <code>zip</code>. If
one buffer is longer than the other, the remaining elements from
the longer buffer are not included.</p>
<p>Example:</p>
<pre><code>motoko include=initialize

let buffer1 = StableBuffer.initPresized&lt;Nat&gt;(2);
StableBuffer.add(buffer1, 1);
StableBuffer.add(buffer1, 2);
StableBuffer.add(buffer1, 3);

let buffer2 = StableBuffer.initPresized&lt;Nat&gt;(2);
StableBuffer.add(buffer2, 4);
StableBuffer.add(buffer2, 5);
StableBuffer.add(buffer2, 6);

let zipped = StableBuffer.zipWith&lt;Nat, Nat, Nat&gt;(buffer1, buffer2, func (x, y) { x + y });
StableBuffer.toArray(zipped) // =&gt; [5, 7, 9]</code></pre>

<p>Runtime: O(min(size1, size2))</p>
<p>Space: O(min(size1, size2))</p>
<p>*Runtime and space assumes that <code>zip</code> runs in O(1) time and space.</p>
</p></div><div class="declaration"><h4 class="function" id="takeWhile"><code><span class="keyword">public func </span><span class="fnname">takeWhile</span>&lt;<span class="type">X</span>&gt;(<span class="parameter">buffer</span> : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;, <span class="parameter">predicate</span> : <span class="type">X</span> -&gt; <span class="type">Bool</span>) : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;</code></h4><p><p>Creates a new buffer taking elements in order from <code>buffer</code> until predicate
returns false.</p>
<p>Example:</p>
<pre><code>motoko include=initialize
import Nat &quot;mo:base/Nat&quot;;

StableBuffer.add(buffer, 1);
StableBuffer.add(buffer, 2);
StableBuffer.add(buffer, 3);

let newBuf = StableBuffer.takeWhile&lt;Nat&gt;(buffer, func (x) { x &lt; 3 });
StableBuffer.toText(newBuf, Nat.toText); // =&gt; [1, 2]</code></pre>

<p>Runtime: O(size)</p>
<p>Space: O(size)</p>
<p>*Runtime and space assumes that <code>predicate</code> runs in O(1) time and space.</p>
</p></div><div class="declaration"><h4 class="function" id="dropWhile"><code><span class="keyword">public func </span><span class="fnname">dropWhile</span>&lt;<span class="type">X</span>&gt;(<span class="parameter">buffer</span> : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;, <span class="parameter">predicate</span> : <span class="type">X</span> -&gt; <span class="type">Bool</span>) : <a href="#type.StableBuffer"><span class="type">StableBuffer</span></a>&lt;<span class="type">X</span>&gt;</code></h4><p><p>Creates a new buffer excluding elements in order from <code>buffer</code> until predicate
returns false.</p>
<p>Example:</p>
<pre><code>motoko include=initialize
import Nat &quot;mo:base/Nat&quot;;

StableBuffer.add(buffer, 1);
StableBuffer.add(buffer, 2);
StableBuffer.add(buffer, 3);

let newBuf = StableBuffer.dropWhile&lt;Nat&gt;(buffer, func x { x &lt; 3 }); // =&gt; [3]
StableBuffer.toText(newBuf, Nat.toText);</code></pre>

<p>Runtime: O(size)</p>
<p>Space: O(size)</p>
<p>*Runtime and space assumes that <code>predicate</code> runs in O(1) time and space.</p>
</p></div></div></body></html>